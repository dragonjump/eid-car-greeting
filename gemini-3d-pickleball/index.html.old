<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Pickleball Lite</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #306090; color: white; font-family: Arial, sans-serif; }
        #container { width: 100%; height: 100%; }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 5px;
            font-size: 13px;
            line-height: 1.4;
        }
        #scoreBoard {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        .message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background-color: rgba(255,255,0,0.8);
            color: black;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            display: none; /* Hidden by default */
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="instructions">
        <b>Pickleball Lite</b><br>
        Move mouse to control your paddle (bottom).<br>
        Click to serve/hit (when ball is close).<br>
        First to 5 points wins!
    </div>
    <div id="scoreBoard">Player: 0 - AI: 0</div>
    <div id="message" class="message">Message Here</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let scene, camera, renderer;
            let world;
            const meshes = []; // To store meshes that need updating from physics bodies
            const bodies = []; // To store physics bodies

            // Game settings
            const COURT_WIDTH = 10;
            const COURT_LENGTH = 20; // Total length
            const NET_HEIGHT = 0.9;
            const PADDLE_WIDTH = 1.2;
            const PADDLE_HEIGHT = 0.2;
            const PADDLE_DEPTH = 1.8;
            const BALL_RADIUS = 0.15;

            // Physics materials
            let ballMaterial, paddleMaterial, courtMaterial, netMaterial;

            // Game objects
            let ballMesh, ballBody;
            let playerPaddleMesh, playerPaddleBody;
            let aiPaddleMesh, aiPaddleBody;
            let netMesh, netBody;

            // Game state
            let playerScore = 0;
            let aiScore = 0;
            const WINNING_SCORE = 5;
            let gameState = "START_GAME"; // START_GAME, SERVING_PLAYER, SERVING_AI, IN_PLAY, POINT_SCORED, GAME_OVER
            let ballInPlay = false;
            let lastPaddleHit = null; // 'player' or 'ai'
            let ballBounces = 0; // On current side after crossing net
            let serveSide = 'player'; // Who is serving next

            const fixedTimeStep = 1 / 60;
            let lastTime = 0;

            const scoreBoardElement = document.getElementById('scoreBoard');
            const messageElement = document.getElementById('message');

            init();
            animate();

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x306090); // Blue sky

                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, COURT_LENGTH * 0.4, COURT_LENGTH * 0.7); // Angled view from player side
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 15, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -COURT_WIDTH * 1.5;
                directionalLight.shadow.camera.right = COURT_WIDTH * 1.5;
                directionalLight.shadow.camera.top = COURT_LENGTH * 1.5;
                directionalLight.shadow.camera.bottom = -COURT_LENGTH * 1.5;
                directionalLight.shadow.camera.far = 50;
                scene.add(directionalLight);

                setupPhysics();
                createCourt();
                createPaddles();
                createBall();

                updateScoreBoard();
                showMessage("Click to Start!", 0); // Indefinite until click

                window.addEventListener('resize', onWindowResize, false);
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                renderer.domElement.addEventListener('click', onClick, false);
            }

            function setupPhysics() {
                world = new CANNON.World();
                world.gravity.set(0, -9.82, 0);
                world.broadphase = new CANNON.NaiveBroadphase();
                world.solver.iterations = 10;

                ballMaterial = new CANNON.Material("ballMaterial");
                paddleMaterial = new CANNON.Material("paddleMaterial");
                courtMaterial = new CANNON.Material("courtMaterial");
                netMaterial = new CANNON.Material("netMaterial");

                world.addContactMaterial(new CANNON.ContactMaterial(courtMaterial, ballMaterial, { friction: 0.2, restitution: 0.75 }));
                world.addContactMaterial(new CANNON.ContactMaterial(paddleMaterial, ballMaterial, { friction: 0.1, restitution: 0.95 }));
                world.addContactMaterial(new CANNON.ContactMaterial(netMaterial, ballMaterial, { friction: 0.1, restitution: 0.2 })); // Net deadens ball
            }

            function createCourt() {
                // Floor
                const courtGeo = new THREE.PlaneGeometry(COURT_WIDTH, COURT_LENGTH);
                const courtMat = new THREE.MeshStandardMaterial({ color: 0x40A040, roughness: 0.8 }); // Green court
                const courtMesh = new THREE.Mesh(courtGeo, courtMat);
                courtMesh.rotation.x = -Math.PI / 2;
                courtMesh.receiveShadow = true;
                scene.add(courtMesh);

                const courtShape = new CANNON.Plane();
                const courtBody = new CANNON.Body({ mass: 0, shape: courtShape, material: courtMaterial });
                courtBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                world.addBody(courtBody);
                courtBody.addEventListener("collide", handleBallCourtCollision);


                // Lines (visual only for simplicity, bounds checked by coordinates)
                const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                // Center line
                let points = [new THREE.Vector3(0, 0.01, -COURT_LENGTH / 2), new THREE.Vector3(0, 0.01, COURT_LENGTH / 2)];
                let geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, lineMat));
                // Baselines
                points = [new THREE.Vector3(-COURT_WIDTH/2, 0.01, -COURT_LENGTH/2), new THREE.Vector3(COURT_WIDTH/2, 0.01, -COURT_LENGTH/2)];
                geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, lineMat));
                points = [new THREE.Vector3(-COURT_WIDTH/2, 0.01, COURT_LENGTH/2), new THREE.Vector3(COURT_WIDTH/2, 0.01, COURT_LENGTH/2)];
                geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, lineMat));
                // Sidelines
                points = [new THREE.Vector3(-COURT_WIDTH/2, 0.01, -COURT_LENGTH/2), new THREE.Vector3(-COURT_WIDTH/2, 0.01, COURT_LENGTH/2)];
                geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, lineMat));
                points = [new THREE.Vector3(COURT_WIDTH/2, 0.01, -COURT_LENGTH/2), new THREE.Vector3(COURT_WIDTH/2, 0.01, COURT_LENGTH/2)];
                geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, lineMat));


                // Net
                const netGeo = new THREE.BoxGeometry(COURT_WIDTH + 0.2, NET_HEIGHT, 0.1);
                const netVisualMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9, transparent: true, opacity: 0.7 });
                netMesh = new THREE.Mesh(netGeo, netVisualMat);
                netMesh.position.y = NET_HEIGHT / 2;
                netMesh.castShadow = true;
                scene.add(netMesh);

                const netShape = new CANNON.Box(new CANNON.Vec3((COURT_WIDTH + 0.2) / 2, NET_HEIGHT / 2, 0.05));
                netBody = new CANNON.Body({ mass: 0, shape: netShape, material: netMaterial });
                netBody.position.y = NET_HEIGHT / 2;
                world.addBody(netBody);
            }

            function createPaddles() {
                const paddleGeo = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
                const playerPaddleMat = new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.5 });
                const aiPaddleMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5 });

                // Player Paddle
                playerPaddleMesh = new THREE.Mesh(paddleGeo, playerPaddleMat);
                playerPaddleMesh.castShadow = true;
                playerPaddleMesh.receiveShadow = true;
                scene.add(playerPaddleMesh);
                const paddleShape = new CANNON.Box(new CANNON.Vec3(PADDLE_WIDTH / 2, PADDLE_HEIGHT / 2, PADDLE_DEPTH / 2));
                playerPaddleBody = new CANNON.Body({ mass: 1, type: CANNON.Body.KINEMATIC, shape: paddleShape, material: paddleMaterial });
                playerPaddleBody.position.set(0, PADDLE_HEIGHT / 2, COURT_LENGTH / 2 - PADDLE_DEPTH);
                world.addBody(playerPaddleBody);
                meshes.push(playerPaddleMesh); bodies.push(playerPaddleBody);

                // AI Paddle
                aiPaddleMesh = new THREE.Mesh(paddleGeo, aiPaddleMat);
                aiPaddleMesh.castShadow = true;
                aiPaddleMesh.receiveShadow = true;
                scene.add(aiPaddleMesh);
                aiPaddleBody = new CANNON.Body({ mass: 1, type: CANNON.Body.KINEMATIC, shape: paddleShape, material: paddleMaterial });
                aiPaddleBody.position.set(0, PADDLE_HEIGHT / 2, -COURT_LENGTH / 2 + PADDLE_DEPTH);
                world.addBody(aiPaddleBody);
                meshes.push(aiPaddleMesh); bodies.push(aiPaddleBody);
            }

            function createBall() {
                const ballGeo = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
                const ballVisualMat = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.3, metalness: 0.1 });
                ballMesh = new THREE.Mesh(ballGeo, ballVisualMat);
                ballMesh.castShadow = true;
                ballMesh.receiveShadow = true;
                scene.add(ballMesh);

                const ballShape = new CANNON.Sphere(BALL_RADIUS);
                ballBody = new CANNON.Body({ mass: 0.1, shape: ballShape, material: ballMaterial });
                ballBody.linearDamping = 0.1;
                ballBody.angularDamping = 0.1;
                world.addBody(ballBody);
                meshes.push(ballMesh); bodies.push(ballBody);
                resetBall();
            }

            function resetBall(servingPlayer = 'player') {
                ballInPlay = false;
                lastPaddleHit = null;
                ballBounces = 0;
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
                ballBody.sleep();

                if (servingPlayer === 'player') {
                    ballBody.position.set(playerPaddleBody.position.x, playerPaddleBody.position.y + BALL_RADIUS + PADDLE_HEIGHT, playerPaddleBody.position.z - PADDLE_DEPTH/2 - BALL_RADIUS - 0.1);
                    gameState = "SERVING_PLAYER";
                    showMessage("Your Serve!", 2000);
                } else { // AI serves
                    ballBody.position.set(aiPaddleBody.position.x, aiPaddleBody.position.y + BALL_RADIUS + PADDLE_HEIGHT, aiPaddleBody.position.z + PADDLE_DEPTH/2 + BALL_RADIUS + 0.1);
                    gameState = "SERVING_AI";
                     showMessage("AI Serves", 2000);
                    // AI simple serve
                    setTimeout(() => {
                        if (gameState === "SERVING_AI") { // ensure state hasn't changed
                            ballBody.wakeUp();
                            ballBody.velocity.set((Math.random()-0.5)*2, 3, -6); // Basic AI serve
                            ballInPlay = true;
                            lastPaddleHit = 'ai';
                            gameState = "IN_PLAY";
                        }
                    }, 1000);
                }
                ballBody.wakeUp(); // Ensure it's active for positioning
            }

            function onMouseMove(event) {
                if(gameState === "GAME_OVER") return;
                const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                // Move player paddle based on mouse X, constrained to court width
                let targetX = mouseX * (COURT_WIDTH / 2 + PADDLE_WIDTH/2); // Scale to court width
                targetX = Math.max(-COURT_WIDTH / 2 + PADDLE_WIDTH / 2, Math.min(COURT_WIDTH / 2 - PADDLE_WIDTH / 2, targetX));
                playerPaddleBody.position.x = targetX;
            }

            function onClick(event) {
                 if (gameState === "START_GAME" || gameState === "POINT_SCORED" || gameState === "GAME_OVER") {
                    if (playerScore >= WINNING_SCORE || aiScore >= WINNING_SCORE) { // If game was over, restart
                        playerScore = 0;
                        aiScore = 0;
                        updateScoreBoard();
                    }
                    hideMessage();
                    serveSide = 'player'; // Player always starts new game
                    resetBall(serveSide);
                    return;
                }

                if (gameState === "SERVING_PLAYER" && !ballInPlay) {
                    ballBody.wakeUp();
                    // Simple serve impulse upwards and forwards
                    const serveImpulse = new CANNON.Vec3( (Math.random()-0.5)*1 , 3, 7); // Forward towards AI
                    ballBody.applyImpulse(serveImpulse, ballBody.position);
                    ballInPlay = true;
                    lastPaddleHit = 'player';
                    gameState = "IN_PLAY";
                } else if (ballInPlay) {
                    // Hit logic if ball is close to player paddle
                    const distanceToBall = playerPaddleBody.position.distanceTo(ballBody.position);
                    if (distanceToBall < PADDLE_DEPTH) { // Approximation
                        // This will be handled by CannonJS contact, but we can add an extra "oomph"
                        // Or, better, rely on the kinematic body's velocity from mouse movement (handled by Cannon)
                        // For a click-hit, you might momentarily give the paddle a sharp velocity.
                        // For now, contact physics will do the main work.
                        // console.log("Player attempts hit");
                    }
                }
            }


            function handleBallPaddleHit(event, paddleType) {
                if (!ballInPlay) return;
                lastPaddleHit = paddleType;
                ballBounces = 0; // Reset bounces on paddle hit
                // Add a bit of upward velocity on hit if desired
                // ballBody.velocity.y = Math.max(ballBody.velocity.y, 2);
            }


            function handleBallCourtCollision(event) {
                if (!ballInPlay || ballBody.position.y > BALL_RADIUS * 2) return; // Only count if near ground

                ballBounces++;
                const hitX = ballBody.position.x;
                const hitZ = ballBody.position.z;

                // Determine which side of the net the ball landed on
                const landedPlayerSide = hitZ > 0;
                const landedAiSide = hitZ < 0;

                let pointTo = null;
                let reason = "";

                if ( // Ball landed OUTSIDE court
                    hitX < -COURT_WIDTH / 2 || hitX > COURT_WIDTH / 2 ||
                    hitZ < -COURT_LENGTH / 2 || hitZ > COURT_LENGTH / 2
                ) {
                    reason = "Out!";
                    pointTo = (lastPaddleHit === 'player') ? 'ai' : 'player';
                } else { // Ball landed INSIDE court
                    if (lastPaddleHit === 'player') { // Player hit it last
                        if (landedAiSide) { // Good hit by player on AI side
                            // AI needs to return it, if it bounces twice on AI side, player point
                            if (ballBounces >= 2) { // Allow one bounce
                                reason = "AI Missed (Double Bounce)";
                                pointTo = 'player';
                            } else { // Still in play for AI
                                // AI will try to hit it
                            }
                        } else if (landedPlayerSide) { // Player hit it on their own side (fault)
                            reason = "Player Fault (Own Side)";
                            pointTo = 'ai';
                        }
                    } else if (lastPaddleHit === 'ai') { // AI hit it last
                        if (landedPlayerSide) { // Good hit by AI on Player side
                            if (ballBounces >= 2) {
                                reason = "Player Missed (Double Bounce)";
                                pointTo = 'ai';
                            } else {
                                // Player needs to return
                            }
                        } else if (landedAiSide) { // AI hit it on its own side (fault)
                            reason = "AI Fault (Own Side)";
                            pointTo = 'player';
                        }
                    }
                }


                if (pointTo) {
                    awardPoint(pointTo, reason);
                }
            }

            function checkBallNetInteraction() {
                if (!ballInPlay) return;

                // A simpler check: if ball Y is low and Z is near 0 after a hit
                if (ballBody.position.y < NET_HEIGHT && Math.abs(ballBody.position.z) < BALL_RADIUS * 2) {
                    // Check if it hit the net AND is on the side of the player who last hit it
                    if (lastPaddleHit === 'player' && ballBody.velocity.z < 0) { // Player hit into net
                        awardPoint('ai', "Player Hit Net");
                    } else if (lastPaddleHit === 'ai' && ballBody.velocity.z > 0) { // AI hit into net
                        awardPoint('player', "AI Hit Net");
                    }
                }
            }


            function awardPoint(winner, reason) {
                if (gameState === "POINT_SCORED" || gameState === "GAME_OVER") return; // Avoid multiple awards

                ballInPlay = false;
                gameState = "POINT_SCORED";
                showMessage(`${reason} ${winner === 'player' ? 'Player' : 'AI'} scores!`, 2500);

                if (winner === 'player') {
                    playerScore++;
                    serveSide = 'player';
                } else {
                    aiScore++;
                    serveSide = 'ai';
                }
                updateScoreBoard();

                if (playerScore >= WINNING_SCORE || aiScore >= WINNING_SCORE) {
                    gameState = "GAME_OVER";
                    const gameWinner = playerScore >= WINNING_SCORE ? "Player" : "AI";
                    showMessage(`${gameWinner} Wins! Final Score ${playerScore}-${aiScore}. Click to Restart.`, 0);
                } else {
                    setTimeout(() => {
                        if (gameState === "POINT_SCORED") { // Check if game hasn't ended
                           resetBall(serveSide);
                        }
                    }, 2600);
                }
            }

            function updateScoreBoard() {
                scoreBoardElement.textContent = `Player: ${playerScore} - AI: ${aiScore}`;
            }

            function showMessage(text, duration = 3000) {
                messageElement.textContent = text;
                messageElement.style.display = 'block';
                if (duration > 0) {
                    setTimeout(hideMessage, duration);
                }
            }
            function hideMessage() {
                messageElement.style.display = 'none';
            }


            function updateAI(deltaTime) {
                if (!ballInPlay || gameState !== "IN_PLAY") {
                    // Keep AI paddle somewhat centered if ball not in play on its side
                     aiPaddleBody.position.x += (0 - aiPaddleBody.position.x) * 0.1 * deltaTime * 50; // Drift to center
                    return;
                }

                // Simple AI: try to move under the ball on its side of the net
                if (ballBody.position.z < -0.5) { // If ball is on AI's side or approaching
                    let targetX = ballBody.position.x;
                    // Predict where ball will be (very basic prediction)
                    if(ballBody.velocity.z < -1) { // if ball moving towards AI
                        const timeToReachNetPlane = Math.abs( (aiPaddleBody.position.z - ballBody.position.z) / ballBody.velocity.z );
                        targetX = ballBody.position.x + ballBody.velocity.x * timeToReachNetPlane * 0.8; // 0.8 to undershoot a bit
                    }

                    targetX = Math.max(-COURT_WIDTH / 2 + PADDLE_WIDTH / 2, Math.min(COURT_WIDTH / 2 - PADDLE_WIDTH / 2, targetX));
                    aiPaddleBody.position.x += (targetX - aiPaddleBody.position.x) * 0.15; // AI speed factor

                    // Simple "hit" logic for AI: if ball is close and low enough, give it an upward whack
                    const distanceToBall = aiPaddleBody.position.distanceTo(ballBody.position);
                    if (distanceToBall < PADDLE_DEPTH * 0.8 && ballBody.position.y < NET_HEIGHT + PADDLE_HEIGHT) {
                        // This relies on the kinematic collision with CannonJS.
                        // To make AI hit harder, you could briefly set its velocity.y or apply an impulse to the ball
                        // upon this condition. For now, we let contact material do its job.
                        // handleBallPaddleHit(null, 'ai'); // This is now handled by actual collision
                    }
                } else { // Ball on player's side, AI returns to a neutral position
                     aiPaddleBody.position.x += (0 - aiPaddleBody.position.x) * 0.1 * deltaTime * 50;
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate(time) {
                requestAnimationFrame(animate);
                const deltaTime = (time && lastTime) ? (time - lastTime) / 1000 : fixedTimeStep;
                lastTime = time;
                let maxSubSteps=10

                if (gameState !== "GAME_OVER" && gameState !== "START_GAME") {
                     world.step(fixedTimeStep, deltaTime, maxSubSteps);
                }


                // Update meshes from physics bodies
                for (let i = 0; i < meshes.length; i++) {
                    if (bodies[i] && meshes[i]) { // Ensure both exist
                        meshes[i].position.copy(bodies[i].position);
                        meshes[i].quaternion.copy(bodies[i].quaternion);
                    }
                }

                if (ballInPlay) {
                    checkBallNetInteraction(); // Check this before court collision for net faults
                    // Ball-paddle collision is now handled by CannonJS contact materials.
                    // We can add event listeners to bodies for more precise hit detection if needed.
                    playerPaddleBody.addEventListener("collide", (event) => {
                        if (event.body === ballBody) handleBallPaddleHit(event, 'player');
                    });
                    aiPaddleBody.addEventListener("collide", (event) => {
                         if (event.body === ballBody) handleBallPaddleHit(event, 'ai');
                    });
                }


                updateAI(deltaTime);

                renderer.render(scene, camera);
            }
        });
    </script>
</body>
</html>